
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>customer: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ming-0x0/hexago/internal/customer/adapter/repository/mysql/customer/adapter.go (96.0%)</option>
				
				<option value="file1">github.com/ming-0x0/hexago/internal/customer/adapter/repository/mysql/customer/repository.go (0.0%)</option>
				
				<option value="file2">github.com/ming-0x0/hexago/internal/customer/domain/customer/customer.go (100.0%)</option>
				
				<option value="file3">github.com/ming-0x0/hexago/internal/customer/domain/customer/customer_accessor.go (0.0%)</option>
				
				<option value="file4">github.com/ming-0x0/hexago/internal/customer/domain/service_type/service_type.go (100.0%)</option>
				
				<option value="file5">github.com/ming-0x0/hexago/internal/customer/domain/service_type/service_type_accessor.go (100.0%)</option>
				
				<option value="file6">github.com/ming-0x0/hexago/internal/customer/domain/status/status.go (100.0%)</option>
				
				<option value="file7">github.com/ming-0x0/hexago/internal/customer/domain/status/status_accessor.go (100.0%)</option>
				
				<option value="file8">github.com/ming-0x0/hexago/internal/shared/dbmocker/dbmocker.go (0.0%)</option>
				
				<option value="file9">github.com/ming-0x0/hexago/internal/shared/domain/email/email.go (100.0%)</option>
				
				<option value="file10">github.com/ming-0x0/hexago/internal/shared/domain/email/email_accessor.go (100.0%)</option>
				
				<option value="file11">github.com/ming-0x0/hexago/internal/shared/errors/error_code.go (0.0%)</option>
				
				<option value="file12">github.com/ming-0x0/hexago/internal/shared/errors/errors.go (0.0%)</option>
				
				<option value="file13">github.com/ming-0x0/hexago/internal/shared/repository/mock/repository.go (0.0%)</option>
				
				<option value="file14">github.com/ming-0x0/hexago/internal/shared/repository/repository.go (100.0%)</option>
				
				<option value="file15">github.com/ming-0x0/hexago/internal/shared/transaction/mock/transaction.go (0.0%)</option>
				
				<option value="file16">github.com/ming-0x0/hexago/internal/shared/transaction/transaction.go (100.0%)</option>
				
				<option value="file17">github.com/ming-0x0/hexago/internal/shared/undefined/undefined.go (0.0%)</option>
				
				<option value="file18">github.com/ming-0x0/hexago/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package customer

import (
        "github.com/ming-0x0/hexago/internal/customer/adapter/repository/mysql/entity"
        "github.com/ming-0x0/hexago/internal/customer/domain/customer"
        "github.com/ming-0x0/hexago/internal/customer/domain/service_type"
        "github.com/ming-0x0/hexago/internal/customer/domain/status"
        "github.com/ming-0x0/hexago/internal/shared/domain/email"
)

type CustomerRepositoryAdapter struct{}

func (a *CustomerRepositoryAdapter) ToDomain(e *entity.Customer) (*customer.Customer, error) <span class="cov8" title="1">{
        email, err := email.New(e.Email)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">serviceType, err := service_type.New(e.ServiceType)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">status, err := status.New(e.Status)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return customer.FromRepository(
                customer.ID(e.ID),
                e.CustomerName,
                *email,
                e.PhoneNumber,
                e.CompanyName,
                e.Message,
                e.Note,
                *serviceType,
                *status,
        )</span>
}

func (a *CustomerRepositoryAdapter) ToEntity(d *customer.Customer) (*entity.Customer, error) <span class="cov8" title="1">{
        return &amp;entity.Customer{
                ID:           string(d.ID()),
                CustomerName: d.CustomerName(),
                Email:        d.Email().Value(),
                PhoneNumber:  d.PhoneNumber(),
                CompanyName:  d.CompanyName(),
                Message:      d.Message(),
                Note:         d.Note(),
                ServiceType:  d.ServiceType().Value(),
                Status:       d.Status().Value(),
        }, nil
}</span>

func (a *CustomerRepositoryAdapter) ToDomains(es []*entity.Customer) ([]*customer.Customer, error) <span class="cov8" title="1">{
        customers := make([]*customer.Customer, 0, len(es))
        for _, e := range es </span><span class="cov8" title="1">{
                customer, err := a.ToDomain(e)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">customers = append(customers, customer)</span>
        }
        <span class="cov8" title="1">return customers, nil</span>
}

func (a *CustomerRepositoryAdapter) ToEntities(ds []*customer.Customer) ([]*entity.Customer, error) <span class="cov8" title="1">{
        customers := make([]*entity.Customer, 0, len(ds))
        for _, d := range ds </span><span class="cov8" title="1">{
                customer, err := a.ToEntity(d)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">customers = append(customers, customer)</span>
        }
        <span class="cov8" title="1">return customers, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package customer

import (
        "github.com/ming-0x0/hexago/internal/customer/adapter/repository/mysql/entity"
        "github.com/ming-0x0/hexago/internal/customer/domain/customer"
        "github.com/ming-0x0/hexago/internal/shared/repository"
        "github.com/sirupsen/logrus"
        "gorm.io/gorm"
)

type CustomerRepository struct {
        *repository.Repository[*CustomerRepositoryAdapter, customer.Customer, entity.Customer]
}

func New(
        db *gorm.DB,
        logger *logrus.Logger,
        adapter *CustomerRepositoryAdapter,
) *CustomerRepository <span class="cov0" title="0">{
        return &amp;CustomerRepository{
                Repository: repository.NewRepository(db, logger, adapter),
        }
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package customer

import (
        validation "github.com/go-ozzo/ozzo-validation/v4"
        "github.com/ming-0x0/hexago/internal/customer/domain/service_type"
        "github.com/ming-0x0/hexago/internal/customer/domain/status"
        "github.com/ming-0x0/hexago/internal/shared/domain/email"
        "github.com/ming-0x0/hexago/internal/shared/errors"
        "github.com/ming-0x0/hexago/internal/shared/undefined"
        "github.com/oklog/ulid/v2"
)

const (
        maxCustomerNameLength = 255
        maxCompanyNameLength  = 255
        maxPhoneNumberLength  = 10
        maxMessageLength      = 1000
        maxNoteLength         = 1000
)

type ID string

//go:generate sh -c "$(go list -m -f '{{.Dir}}')/bin/accessor -type=Customer"
type Customer struct {
        id           ID
        customerName string
        email        email.Email
        phoneNumber  string
        companyName  undefined.Undefined[string]
        message      undefined.Undefined[string]
        note         undefined.Undefined[string]
        serviceType  service_type.ServiceType
        status       status.Status
}

func New(
        customerName string,
        email email.Email,
        phoneNumber string,
        companyName undefined.Undefined[string],
        message undefined.Undefined[string],
        note undefined.Undefined[string],
        serviceType service_type.ServiceType,
        status status.Status,
) (*Customer, error) <span class="cov8" title="1">{
        customer := &amp;Customer{
                id:           ID(ulid.Make().String()),
                customerName: customerName,
                email:        email,
                phoneNumber:  phoneNumber,
                companyName:  companyName,
                message:      message,
                note:         note,
                serviceType:  serviceType,
                status:       status,
        }

        if err := customer.validate(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return customer, nil</span>
}

func FromRepository(
        id ID,
        customerName string,
        email email.Email,
        phoneNumber string,
        companyName undefined.Undefined[string],
        message undefined.Undefined[string],
        note undefined.Undefined[string],
        serviceType service_type.ServiceType,
        status status.Status,
) (*Customer, error) <span class="cov8" title="1">{
        customer := &amp;Customer{
                id:           id,
                customerName: customerName,
                email:        email,
                phoneNumber:  phoneNumber,
                companyName:  companyName,
                message:      message,
                note:         note,
                serviceType:  serviceType,
                status:       status,
        }

        if err := customer.validate(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return customer, nil</span>
}

func (c *Customer) validate() error <span class="cov8" title="1">{
        err := validation.ValidateStruct(c,
                validation.Field(
                        &amp;c.customerName,
                        validation.Required,
                        validation.Length(1, maxCustomerNameLength),
                ),
                validation.Field(
                        &amp;c.phoneNumber,
                        validation.Required,
                        validation.Length(maxPhoneNumberLength, maxPhoneNumberLength),
                ),
                validation.Field(
                        &amp;c.companyName,
                        validation.Length(0, maxCompanyNameLength),
                ),
                validation.Field(
                        &amp;c.message,
                        validation.Length(0, maxMessageLength),
                ),
                validation.Field(
                        &amp;c.note,
                        validation.Length(0, maxNoteLength),
                ),
        )
        if err != nil </span><span class="cov8" title="1">{
                return errors.NewDomainError(errors.Validation, err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by "accessor -type=Customer"; DO NOT EDIT.

package customer

import (
        "github.com/ming-0x0/hexago/internal/customer/domain/service_type"
        "github.com/ming-0x0/hexago/internal/customer/domain/status"
        "github.com/ming-0x0/hexago/internal/shared/domain/email"
        "github.com/ming-0x0/hexago/internal/shared/undefined"
)

// ID return id value
func (t Customer) ID() ID <span class="cov0" title="0">{
        return t.id
}</span>

// CustomerName return customerName value
func (t Customer) CustomerName() string <span class="cov0" title="0">{
        return t.customerName
}</span>

// Email return email value
func (t Customer) Email() email.Email <span class="cov0" title="0">{
        return t.email
}</span>

// PhoneNumber return phoneNumber value
func (t Customer) PhoneNumber() string <span class="cov0" title="0">{
        return t.phoneNumber
}</span>

// CompanyName return companyName value
func (t Customer) CompanyName() undefined.Undefined[string] <span class="cov0" title="0">{
        return t.companyName
}</span>

// Message return message value
func (t Customer) Message() undefined.Undefined[string] <span class="cov0" title="0">{
        return t.message
}</span>

// Note return note value
func (t Customer) Note() undefined.Undefined[string] <span class="cov0" title="0">{
        return t.note
}</span>

// ServiceType return serviceType value
func (t Customer) ServiceType() service_type.ServiceType <span class="cov0" title="0">{
        return t.serviceType
}</span>

// Status return status value
func (t Customer) Status() status.Status <span class="cov0" title="0">{
        return t.status
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package service_type

import (
        validation "github.com/go-ozzo/ozzo-validation/v4"
        "github.com/ming-0x0/hexago/internal/shared/errors"
)

var (
        TuyenDung = ServiceType{value: 1}
        LienHe    = ServiceType{value: 2}
        KhoaHoc   = ServiceType{value: 3}
)

//go:generate sh -c "$(go list -m -f '{{.Dir}}')/bin/accessor -type=ServiceType"
type ServiceType struct {
        value int64
}

func New(value int64) (*ServiceType, error) <span class="cov8" title="1">{
        s := &amp;ServiceType{value: value}
        if err := s.validate(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return s, nil</span>
}

func (s *ServiceType) validate() error <span class="cov8" title="1">{
        err := validation.ValidateStruct(s,
                validation.Field(
                        &amp;s.value,
                        validation.Required,
                        validation.In(TuyenDung.value, LienHe.value, KhoaHoc.value),
                ),
        )
        if err != nil </span><span class="cov8" title="1">{
                return errors.NewDomainError(errors.Validation, err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by "accessor -type=ServiceType"; DO NOT EDIT.

package service_type

// Value return value value
func (t ServiceType) Value() int64 <span class="cov8" title="1">{
        return t.value
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package status

import (
        validation "github.com/go-ozzo/ozzo-validation/v4"
        "github.com/ming-0x0/hexago/internal/shared/errors"
)

var (
        Replied   = Status{value: 1}
        Unreplied = Status{value: 2}
)

//go:generate sh -c "$(go list -m -f '{{.Dir}}')/bin/accessor -type=Status"
type Status struct {
        value int64
}

func New(value int64) (*Status, error) <span class="cov8" title="1">{
        s := &amp;Status{value: value}
        if err := s.validate(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return s, nil</span>
}

func (s *Status) validate() error <span class="cov8" title="1">{
        err := validation.ValidateStruct(s,
                validation.Field(
                        &amp;s.value,
                        validation.Required,
                        validation.In(Replied.value, Unreplied.value),
                ),
        )
        if err != nil </span><span class="cov8" title="1">{
                return errors.NewDomainError(errors.Validation, err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by "accessor -type=Status"; DO NOT EDIT.

package status

// Value return value value
func (t Status) Value() int64 <span class="cov8" title="1">{
        return t.value
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package dbmocker

import (
        "database/sql"

        "github.com/DATA-DOG/go-sqlmock"
        "github.com/sirupsen/logrus"
        "gorm.io/driver/mysql"
        "gorm.io/gorm"
        gormLog "gorm.io/gorm/logger"
)

type MockedRepository struct {
        DB      *sql.DB
        GormDB  *gorm.DB
        SqlMock sqlmock.Sqlmock
        Logger  *logrus.Logger
}

func NewMockedDB() (*MockedRepository, error) <span class="cov0" title="0">{
        logger := logrus.New()
        logger.SetLevel(logrus.WarnLevel)
        logger.SetFormatter(&amp;logrus.TextFormatter{
                ForceColors: true,
        })
        db, sqlMock, err := sqlmock.New()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">sqlMock.MatchExpectationsInOrder(false)

        gormConfig := &amp;gorm.Config{}
        gormConfig.Logger = gormLog.New(logger, gormLog.Config{
                LogLevel: gormLog.Warn,
                Colorful: true,
        })

        gormDB, err := gorm.Open(
                mysql.New(mysql.Config{
                        Conn:                      db,
                        SkipInitializeWithVersion: true,
                }),
                gormConfig,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;MockedRepository{
                DB:      db,
                GormDB:  gormDB,
                SqlMock: sqlMock,
                Logger:  logger,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package email

import (
        validation "github.com/go-ozzo/ozzo-validation/v4"
        "github.com/go-ozzo/ozzo-validation/v4/is"
        "github.com/ming-0x0/hexago/internal/shared/errors"
)

//go:generate sh -c "$(go list -m -f '{{.Dir}}')/bin/accessor -type=Email"
type Email struct {
        value string
}

func New(value string) (*Email, error) <span class="cov8" title="1">{
        e := &amp;Email{
                value: value,
        }

        if err := e.validate(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return e, nil</span>
}

func (e *Email) validate() error <span class="cov8" title="1">{
        err := validation.ValidateStruct(e,
                validation.Field(&amp;e.value, validation.Required, is.Email),
        )
        if err != nil </span><span class="cov8" title="1">{
                return errors.NewDomainError(errors.Validation, err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by "accessor -type=Email"; DO NOT EDIT.

package email

// Value return value value
func (t Email) Value() string <span class="cov8" title="1">{
        return t.value
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package errors

type ErrorCode int

func (e ErrorCode) Code() int <span class="cov0" title="0">{
        return int(e)
}</span>

const (
        // common 1 -&gt; 1000
        System ErrorCode = iota + 1
        Validation
        BadRequest
        NotAuthorized
        Forbidden
        NotFound
        AlreadyExist
        // module specific 1001 -&gt; 2000
)
</pre>
		
		<pre class="file" id="file12" style="display: none">package errors

import "errors"

type DomainError struct {
        ErrCode ErrorCode
        err     error
}

func (e *DomainError) Error() string <span class="cov0" title="0">{
        if e == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return e.err.Error()</span>
}

func (e *DomainError) Unwrap() error <span class="cov0" title="0">{
        if e == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return e.err</span>
}

func (e *DomainError) ErrorCode() ErrorCode <span class="cov0" title="0">{
        if e == nil </span><span class="cov0" title="0">{
                return System
        }</span>
        <span class="cov0" title="0">return e.ErrCode</span>
}

func NewDomainError(errCode ErrorCode, message string) *DomainError <span class="cov0" title="0">{
        return &amp;DomainError{
                ErrCode: errCode,
                err:     errors.New(message),
        }
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ming-0x0/hexago/internal/shared/repository (interfaces: RepositoryInterface)
//
// Generated by this command:
//
//        mockgen -destination mock/repository.go -package mock github.com/ming-0x0/hexago/internal/shared/repository RepositoryInterface
//

// Package mock is a generated GoMock package.
package mock

import (
        context "context"
        reflect "reflect"

        repository "github.com/ming-0x0/hexago/internal/shared/repository"
        gomock "go.uber.org/mock/gomock"
        gorm "gorm.io/gorm"
)

// MockRepositoryInterface is a mock of RepositoryInterface interface.
type MockRepositoryInterface[A repository.AdapterInterface[D, E], D any, E any] struct {
        ctrl     *gomock.Controller
        recorder *MockRepositoryInterfaceMockRecorder[A, D, E]
        isgomock struct{}
}

// MockRepositoryInterfaceMockRecorder is the mock recorder for MockRepositoryInterface.
type MockRepositoryInterfaceMockRecorder[A repository.AdapterInterface[D, E], D any, E any] struct {
        mock *MockRepositoryInterface[A, D, E]
}

// NewMockRepositoryInterface creates a new mock instance.
func NewMockRepositoryInterface[A repository.AdapterInterface[D, E], D any, E any](ctrl *gomock.Controller) *MockRepositoryInterface[A, D, E] <span class="cov0" title="0">{
        mock := &amp;MockRepositoryInterface[A, D, E]{ctrl: ctrl}
        mock.recorder = &amp;MockRepositoryInterfaceMockRecorder[A, D, E]{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepositoryInterface[A, D, E]) EXPECT() *MockRepositoryInterfaceMockRecorder[A, D, E] <span class="cov0" title="0">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockRepositoryInterface[A, D, E]) Create(ctx context.Context, domain *D) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", ctx, domain)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockRepositoryInterfaceMockRecorder[A, D, E]) Create(ctx, domain any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockRepositoryInterface[A, D, E])(nil).Create), ctx, domain)
}</span>

// DeleteByConditions mocks base method.
func (m *MockRepositoryInterface[A, D, E]) DeleteByConditions(ctx context.Context, conditions map[string]any) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteByConditions", ctx, conditions)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteByConditions indicates an expected call of DeleteByConditions.
func (mr *MockRepositoryInterfaceMockRecorder[A, D, E]) DeleteByConditions(ctx, conditions any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteByConditions", reflect.TypeOf((*MockRepositoryInterface[A, D, E])(nil).DeleteByConditions), ctx, conditions)
}</span>

// FindByConditions mocks base method.
func (m *MockRepositoryInterface[A, D, E]) FindByConditions(ctx context.Context, conditions map[string]any, scopes ...func(*gorm.DB) *gorm.DB) ([]*D, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx, conditions}
        for _, a := range scopes </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "FindByConditions", varargs...)
        ret0, _ := ret[0].([]*D)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// FindByConditions indicates an expected call of FindByConditions.
func (mr *MockRepositoryInterfaceMockRecorder[A, D, E]) FindByConditions(ctx, conditions any, scopes ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx, conditions}, scopes...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByConditions", reflect.TypeOf((*MockRepositoryInterface[A, D, E])(nil).FindByConditions), varargs...)
}</span>

// FindByConditionsWithPagination mocks base method.
func (m *MockRepositoryInterface[A, D, E]) FindByConditionsWithPagination(ctx context.Context, pageData map[string]int, conditions map[string]any, scopes ...func(*gorm.DB) *gorm.DB) ([]*D, int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx, pageData, conditions}
        for _, a := range scopes </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "FindByConditionsWithPagination", varargs...)
        ret0, _ := ret[0].([]*D)
        ret1, _ := ret[1].(int64)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2</span>
}

// FindByConditionsWithPagination indicates an expected call of FindByConditionsWithPagination.
func (mr *MockRepositoryInterfaceMockRecorder[A, D, E]) FindByConditionsWithPagination(ctx, pageData, conditions any, scopes ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx, pageData, conditions}, scopes...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByConditionsWithPagination", reflect.TypeOf((*MockRepositoryInterface[A, D, E])(nil).FindByConditionsWithPagination), varargs...)
}</span>

// Save mocks base method.
func (m *MockRepositoryInterface[A, D, E]) Save(ctx context.Context, domain *D) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Save", ctx, domain)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Save indicates an expected call of Save.
func (mr *MockRepositoryInterfaceMockRecorder[A, D, E]) Save(ctx, domain any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Save", reflect.TypeOf((*MockRepositoryInterface[A, D, E])(nil).Save), ctx, domain)
}</span>

// TakeByConditions mocks base method.
func (m *MockRepositoryInterface[A, D, E]) TakeByConditions(ctx context.Context, conditions map[string]any, scopes ...func(*gorm.DB) *gorm.DB) (*D, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx, conditions}
        for _, a := range scopes </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "TakeByConditions", varargs...)
        ret0, _ := ret[0].(*D)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// TakeByConditions indicates an expected call of TakeByConditions.
func (mr *MockRepositoryInterfaceMockRecorder[A, D, E]) TakeByConditions(ctx, conditions any, scopes ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx, conditions}, scopes...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TakeByConditions", reflect.TypeOf((*MockRepositoryInterface[A, D, E])(nil).TakeByConditions), varargs...)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package repository

import (
        "context"
        "errors"

        sharedErrors "github.com/ming-0x0/hexago/internal/shared/errors"
        "github.com/ming-0x0/hexago/internal/shared/transaction"
        "github.com/sirupsen/logrus"
        "gorm.io/gorm"
)

const (
        DefaultPage    = 1
        DefaultPerPage = 20
)

type AdapterInterface[D, E any] interface {
        // ToDomain converts the entity to its domain representation.
        ToDomain(*E) (*D, error)
        // ToEntity converts the domain to its entity representation.
        ToEntity(*D) (*E, error)
        // ToDomains converts the entities to their domain representations.
        ToDomains([]*E) ([]*D, error)
        // ToEntities converts the domains to their entity representations.
        ToEntities([]*D) ([]*E, error)
}

//go:generate go tool mockgen -destination mock/repository.go -package mock github.com/ming-0x0/hexago/internal/shared/repository RepositoryInterface
type RepositoryInterface[A AdapterInterface[D, E], D, E any] interface {
        Create(
                ctx context.Context,
                domain *D,
        ) error
        FindByConditions(
                ctx context.Context,
                conditions map[string]any,
                scopes ...func(*gorm.DB) *gorm.DB,
        ) ([]*D, error)
        TakeByConditions(
                ctx context.Context,
                conditions map[string]any,
                scopes ...func(*gorm.DB) *gorm.DB,
        ) (*D, error)
        Save(
                ctx context.Context,
                domain *D,
        ) error
        DeleteByConditions(
                ctx context.Context,
                conditions map[string]any,
        ) error
        FindByConditionsWithPagination(
                ctx context.Context,
                pageData map[string]int,
                conditions map[string]any,
                scopes ...func(*gorm.DB) *gorm.DB,
        ) ([]*D, int64, error)
}

type Repository[A AdapterInterface[D, E], D, E any] struct {
        db      *gorm.DB
        logger  *logrus.Logger
        adapter A
}

func NewRepository[A AdapterInterface[D, E], D, E any](
        db *gorm.DB,
        logger *logrus.Logger,
        adapter A,
) *Repository[A, D, E] <span class="cov8" title="1">{
        return &amp;Repository[A, D, E]{
                db:      db,
                logger:  logger,
                adapter: adapter,
        }
}</span>

func (r *Repository[A, D, E]) DB(ctx context.Context) *gorm.DB <span class="cov8" title="1">{
        if tx, ok := transaction.TransactionFromContext(ctx); ok </span><span class="cov8" title="1">{
                return tx
        }</span>

        <span class="cov8" title="1">return r.db.WithContext(ctx)</span>
}

func (r *Repository[A, D, E]) pagination(pageData map[string]int) func(*gorm.DB) *gorm.DB <span class="cov8" title="1">{
        return func(db *gorm.DB) *gorm.DB </span><span class="cov8" title="1">{
                page := DefaultPage
                if valPage, ok := pageData["page"]; ok &amp;&amp; valPage &gt; 0 </span><span class="cov8" title="1">{
                        page = valPage
                }</span>

                <span class="cov8" title="1">pageSize := DefaultPerPage
                if valPageSize, ok := pageData["limit"]; ok &amp;&amp; valPageSize &gt; 0 </span><span class="cov8" title="1">{
                        pageSize = valPageSize
                }</span>

                <span class="cov8" title="1">offset := (page - 1) * pageSize
                return db.Offset(offset).Limit(pageSize)</span>
        }
}

func (r *Repository[A, D, E]) Create(
        ctx context.Context,
        domain *D,
) error <span class="cov8" title="1">{
        entity, err := r.adapter.ToEntity(domain)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = r.DB(ctx).Create(entity).Error
        if err != nil </span><span class="cov8" title="1">{
                return sharedErrors.NewDomainError(sharedErrors.System, err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *Repository[A, D, E]) FindByConditions(
        ctx context.Context,
        conditions map[string]any,
        scopes ...func(*gorm.DB) *gorm.DB,
) ([]*D, error) <span class="cov8" title="1">{
        var entities []*E
        if err := r.DB(ctx).Scopes(scopes...).Where(conditions).Find(&amp;entities).Error; err != nil </span><span class="cov8" title="1">{
                return nil, sharedErrors.NewDomainError(sharedErrors.System, err.Error())
        }</span>

        <span class="cov8" title="1">return r.adapter.ToDomains(entities)</span>
}

func (r *Repository[A, D, E]) TakeByConditions(
        ctx context.Context,
        conditions map[string]any,
        scopes ...func(*gorm.DB) *gorm.DB,
) (*D, error) <span class="cov8" title="1">{
        entity := new(E)
        err := r.DB(ctx).Scopes(scopes...).Where(conditions).Take(entity).Error
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                        return nil, sharedErrors.NewDomainError(sharedErrors.NotFound, err.Error())
                }</span>

                <span class="cov8" title="1">return nil, sharedErrors.NewDomainError(sharedErrors.System, err.Error())</span>
        }

        <span class="cov8" title="1">return r.adapter.ToDomain(entity)</span>
}

func (r *Repository[A, D, E]) Save(
        ctx context.Context,
        domain *D,
) error <span class="cov8" title="1">{
        entity, err := r.adapter.ToEntity(domain)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = r.DB(ctx).Save(entity).Error
        if err != nil </span><span class="cov8" title="1">{
                return sharedErrors.NewDomainError(sharedErrors.System, err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *Repository[A, D, E]) DeleteByConditions(
        ctx context.Context,
        conditions map[string]any,
) error <span class="cov8" title="1">{
        entity := new(E)
        err := r.DB(ctx).Where(conditions).Delete(entity).Error
        if err != nil </span><span class="cov8" title="1">{
                return sharedErrors.NewDomainError(sharedErrors.System, err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *Repository[A, D, E]) FindByConditionsWithPagination(
        ctx context.Context,
        pageData map[string]int,
        conditions map[string]any,
        scopes ...func(*gorm.DB) *gorm.DB,
) ([]*D, int64, error) <span class="cov8" title="1">{
        cdb := r.DB(ctx)

        var entities []*E
        var count int64

        countBuilder := cdb.Model(&amp;entities)
        queryBuilder := cdb.Scopes(r.pagination(pageData))

        err := countBuilder.Scopes(scopes...).Where(conditions).Count(&amp;count).Error
        if err != nil </span><span class="cov8" title="1">{
                return []*D{}, 0, sharedErrors.NewDomainError(sharedErrors.System, err.Error())
        }</span>

        <span class="cov8" title="1">err = queryBuilder.Scopes(scopes...).Where(conditions).Find(&amp;entities).Error
        if err != nil </span><span class="cov8" title="1">{
                return []*D{}, 0, sharedErrors.NewDomainError(sharedErrors.System, err.Error())
        }</span>

        <span class="cov8" title="1">domains, err := r.adapter.ToDomains(entities)
        if err != nil </span><span class="cov8" title="1">{
                return []*D{}, 0, err
        }</span>

        <span class="cov8" title="1">return domains, count, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ming-0x0/hexago/internal/shared/transaction (interfaces: TransactionInterface)
//
// Generated by this command:
//
//        mockgen -destination mock/transaction.go -package mock github.com/ming-0x0/hexago/internal/shared/transaction TransactionInterface
//

// Package mock is a generated GoMock package.
package mock

import (
        context "context"
        reflect "reflect"

        gomock "go.uber.org/mock/gomock"
)

// MockTransactionInterface is a mock of TransactionInterface interface.
type MockTransactionInterface struct {
        ctrl     *gomock.Controller
        recorder *MockTransactionInterfaceMockRecorder
        isgomock struct{}
}

// MockTransactionInterfaceMockRecorder is the mock recorder for MockTransactionInterface.
type MockTransactionInterfaceMockRecorder struct {
        mock *MockTransactionInterface
}

// NewMockTransactionInterface creates a new mock instance.
func NewMockTransactionInterface(ctrl *gomock.Controller) *MockTransactionInterface <span class="cov0" title="0">{
        mock := &amp;MockTransactionInterface{ctrl: ctrl}
        mock.recorder = &amp;MockTransactionInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTransactionInterface) EXPECT() *MockTransactionInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Do mocks base method.
func (m *MockTransactionInterface) Do(ctx context.Context, fn func(context.Context) error) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Do", ctx, fn)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Do indicates an expected call of Do.
func (mr *MockTransactionInterfaceMockRecorder) Do(ctx, fn any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Do", reflect.TypeOf((*MockTransactionInterface)(nil).Do), ctx, fn)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package transaction

import (
        "context"

        "gorm.io/gorm"
)

type TxKey string

const (
        Tx TxKey = "tx"
)

//go:generate go tool mockgen -destination mock/transaction.go -package mock github.com/ming-0x0/hexago/internal/shared/transaction TransactionInterface
type TransactionInterface interface {
        Do(ctx context.Context, fn func(ctx context.Context) error) error
}

type Transaction struct {
        db *gorm.DB
}

func NewTransaction(db *gorm.DB) *Transaction <span class="cov8" title="1">{
        return &amp;Transaction{
                db: db,
        }
}</span>

func (t *Transaction) Do(ctx context.Context, fn func(ctx context.Context) error) error <span class="cov8" title="1">{
        return t.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov8" title="1">{
                ctx = context.WithValue(ctx, Tx, tx)
                return fn(ctx)
        }</span>)
}

func TransactionFromContext(ctx context.Context) (*gorm.DB, bool) <span class="cov8" title="1">{
        v := ctx.Value(Tx)
        if v != nil </span><span class="cov8" title="1">{
                if tx, ok := v.(*gorm.DB); ok </span><span class="cov8" title="1">{
                        return tx, true
                }</span>
        }
        <span class="cov8" title="1">return nil, false</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package undefined

import (
        "database/sql"
        "database/sql/driver"
        "encoding"
        "encoding/json"
        "errors"
        "fmt"
        "reflect"
)

// Verify interface implementations
var (
        _ json.Marshaler           = (*Undefined[any])(nil)
        _ json.Unmarshaler         = (*Undefined[any])(nil)
        _ encoding.TextUnmarshaler = (*Undefined[any])(nil)
        _ driver.Valuer            = (*Undefined[any])(nil)
        _ sql.Scanner              = (*Undefined[any])(nil)
)

// Undefined is a generic wrapper type that can represent a value that may be explicitly
// undefined or unset, which is particularly useful for:
//   - JSON marshaling/unmarshaling where fields can be omitted
//   - Database operations where NULL values need to be distinguished from zero values
//
// Supported types for T include:
//   - Basic types: int64, float64, bool, string
//   - time.Time for timestamp handling
//   - []byte for binary data
//   - nil for explicit NULL values in databases
//
// The zero value of Undefined[T] is considered undefined (valid = false).
type Undefined[T any] struct {
        value T
        valid bool
}

func New[T any](value T) Undefined[T] <span class="cov0" title="0">{
        return Undefined[T]{
                value: value,
                valid: true,
        }
}</span>

func (u Undefined[T]) Get() T <span class="cov0" title="0">{
        return u.value
}</span>

func (u *Undefined[T]) Set(value T) <span class="cov0" title="0">{
        u.value = value
        u.valid = true
}</span>

func (u *Undefined[T]) Unset() <span class="cov0" title="0">{
        var v T
        u.value = v
        u.valid = false
}</span>

// Implement json.Unmarshaler
func (u *Undefined[T]) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        if err := json.Unmarshal(data, &amp;u.value); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">u.valid = true
        return nil</span>
}

// Implement json.Marshaler
func (u Undefined[T]) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        data, err := json.Marshal(u.value)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return data, nil</span>
}

// Implement encoding.TextUnmarshaler
func (u *Undefined[T]) UnmarshalText(text []byte) error <span class="cov0" title="0">{
        u.valid = len(text) &gt; 0
        if textUnmarshaler, ok := any(&amp;u.value).(encoding.TextUnmarshaler); ok </span><span class="cov0" title="0">{
                if err := textUnmarshaler.UnmarshalText(text); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">u.valid = true
                return nil</span>
        }

        <span class="cov0" title="0">return errors.New("Undefined: cannot unmarshal text: underlying value doesn't implement encoding.TextUnmarshaler")</span>
}

// Implement driver.Valuer
func (u Undefined[T]) Value() (driver.Value, error) <span class="cov0" title="0">{
        if !u.valid </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">if valuer, ok := any(u.value).(driver.Valuer); ok </span><span class="cov0" title="0">{
                v, err := valuer.Value()
                return v, err
        }</span>
        <span class="cov0" title="0">return u.value, nil</span>
}

// Implement sql.Scanner
func (u *Undefined[T]) Scan(src any) error <span class="cov0" title="0">{
        u.valid = true

        switch val := src.(type) </span>{
        case nil:<span class="cov0" title="0">
                var t T
                u.value = t</span>
        case Undefined[T]:<span class="cov0" title="0">
                u.value = val.value</span>
        case *Undefined[T]:<span class="cov0" title="0">
                if val == nil </span><span class="cov0" title="0">{
                        var t T
                        u.value = t
                }</span> else<span class="cov0" title="0"> {
                        u.value = val.value
                }</span>
        case T:<span class="cov0" title="0">
                u.value = val</span>
        case *T:<span class="cov0" title="0">
                if val == nil </span><span class="cov0" title="0">{
                        var t T
                        u.value = t
                }</span> else<span class="cov0" title="0"> {
                        u.value = *val
                }</span>
        default:<span class="cov0" title="0">
                if scanner, ok := any(&amp;u.value).(sql.Scanner); ok </span><span class="cov0" title="0">{
                        return scanner.Scan(src)
                }</span>
                <span class="cov0" title="0">var t T
                return fmt.Errorf("Undefined: Scan() incompatible types (src: %T, dst: %T)", src, t)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (u Undefined[T]) IsUndefined() bool <span class="cov0" title="0">{
        return !u.valid
}</span>

func (u Undefined[T]) Ptr() *T <span class="cov0" title="0">{
        if u.valid </span><span class="cov0" title="0">{
                return &amp;u.value
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (u Undefined[T]) Equal(other Undefined[T]) bool <span class="cov0" title="0">{
        if u.valid != other.valid </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if !u.valid </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return reflect.DeepEqual(u.value, other.value)</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package main

import (
        "bytes"
        "flag"
        "fmt"
        "go/ast"
        "go/build"
        "go/format"
        "go/parser"
        "go/token"
        "io/ioutil"
        "log"
        "os"
        "path/filepath"
        "regexp"
        "strings"

        "golang.org/x/text/cases"
        "golang.org/x/text/language"
        "golang.org/x/tools/imports"
)

func main() <span class="cov0" title="0">{
        log.SetPrefix("accessor: ")

        var typeName, output string
        var setter bool
        flag.StringVar(&amp;typeName, "type", "", "type name")
        flag.StringVar(&amp;output, "output", "", "output file name. default: srcdir/{type}_accessor.go")
        flag.BoolVar(&amp;setter, "setter", false, "generate setter")
        flag.Parse()

        if typeName == "" </span><span class="cov0" title="0">{
                flag.Usage()
                os.Exit(2)
        }</span>

        <span class="cov0" title="0">args := flag.Args()
        if len(args) == 0 </span><span class="cov0" title="0">{
                args = []string{"."}
        }</span>

        <span class="cov0" title="0">gen := generator{
                cmdArgs:    os.Args[1:],
                withSetter: setter,
        }
        var dir string
        if len(args) == 1 &amp;&amp; isDirectory(args[0]) </span><span class="cov0" title="0">{
                dir = args[0]
                gen.parsePackageDir(args[0])
        }</span> else<span class="cov0" title="0"> {
                dir = filepath.Dir(args[0])
                gen.parsePackageFiles(args)
        }</span>

        <span class="cov0" title="0">if output == "" </span><span class="cov0" title="0">{
                output = filepath.Join(dir, fmt.Sprintf("%s_accessor.go", camelToSnake(typeName)))
        }</span>

        <span class="cov0" title="0">data, err := imports.Process(output, gen.generate(typeName), nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("go import failed: %s", err)
        }</span>

        <span class="cov0" title="0">if err := ioutil.WriteFile(output, data, 0644); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("write file(%s) failed: %s", output, err)
        }</span>
}

func isDirectory(name string) bool <span class="cov0" title="0">{
        info, err := os.Stat(name)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("os stat failed:%s", err)
        }</span>
        <span class="cov0" title="0">return info.IsDir()</span>
}

type generator struct {
        cmdArgs    []string
        withSetter bool
        buf        bytes.Buffer
        pkg        *pkg
}

func (g *generator) Printf(format string, args ...interface{}) <span class="cov0" title="0">{
        fmt.Fprintf(&amp;g.buf, format, args...)
}</span>

type file struct {
        pkg  *pkg
        file *ast.File
}

type pkg struct {
        dir   string
        name  string
        files []*file
}

func (g *generator) parsePackageDir(dir string) <span class="cov0" title="0">{
        pkg, err := build.Default.ImportDir(dir, 0)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("import dir(%s) failed:%s", dir, err)
        }</span>

        <span class="cov0" title="0">var names []string
        names = append(names, pkg.GoFiles...)
        names = append(names, pkg.CgoFiles...)

        g.parsePackage(dir, makePath(dir, names))</span>
}

func (g *generator) parsePackageFiles(names []string) <span class="cov0" title="0">{
        g.parsePackage(".", names)
}</span>

func makePath(dir string, names []string) []string <span class="cov0" title="0">{
        if dir == "." </span><span class="cov0" title="0">{
                return names
        }</span>
        <span class="cov0" title="0">ret := make([]string, len(names))
        for i, name := range names </span><span class="cov0" title="0">{
                ret[i] = filepath.Join(dir, name)
        }</span>
        <span class="cov0" title="0">return ret</span>
}

func (g *generator) parsePackage(dir string, names []string) <span class="cov0" title="0">{
        var files []*file
        var astFiles []*ast.File
        g.pkg = new(pkg)
        fs := token.NewFileSet()
        for _, name := range names </span><span class="cov0" title="0">{
                if !strings.HasSuffix(name, ".go") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">parsedFile, err := parser.ParseFile(fs, name, nil, parser.ParseComments)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("parse package %s failed: %s", name, err)
                }</span>
                <span class="cov0" title="0">astFiles = append(astFiles, parsedFile)
                files = append(files, &amp;file{
                        file: parsedFile,
                        pkg:  g.pkg,
                })</span>
        }
        <span class="cov0" title="0">if len(astFiles) == 0 </span><span class="cov0" title="0">{
                log.Fatalf("no buildable go files:%s", dir)
        }</span>
        <span class="cov0" title="0">g.pkg.name = astFiles[0].Name.Name
        g.pkg.files = files
        g.pkg.dir = dir</span>
}

func (g *generator) generate(typeName string) []byte <span class="cov0" title="0">{
        var stype *ast.StructType
        var typeParams *ast.FieldList
        baseTypeName := strings.Split(typeName, "[")[0]

        for _, file := range g.pkg.files </span><span class="cov0" title="0">{
                if file.file == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">ast.Inspect(file.file, func(node ast.Node) bool </span><span class="cov0" title="0">{
                        decl, ok := node.(*ast.GenDecl)
                        if !ok || decl.Tok != token.TYPE </span><span class="cov0" title="0">{
                                return true
                        }</span>
                        <span class="cov0" title="0">for _, spec := range decl.Specs </span><span class="cov0" title="0">{
                                tspec := spec.(*ast.TypeSpec)
                                if tspec.Name.Name != baseTypeName </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">styp, ok := tspec.Type.(*ast.StructType)
                                if ok </span><span class="cov0" title="0">{
                                        stype = styp
                                        typeParams = tspec.TypeParams
                                        return false
                                }</span>
                        }
                        <span class="cov0" title="0">return true</span>
                })
        }

        <span class="cov0" title="0">if stype == nil </span><span class="cov0" title="0">{
                log.Fatalf("not exist type %s", typeName)
        }</span>

        <span class="cov0" title="0">g.Printf("// Code generated by \"accessor %s\"; DO NOT EDIT.\n\n", strings.Join(g.cmdArgs, " "))
        g.Printf("package %s\n", g.pkg.name)

        g.build(baseTypeName, stype, typeParams)

        src, err := format.Source(g.buf.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("format source failed:%s", err)
        }</span>
        <span class="cov0" title="0">g.buf.Reset()
        return src</span>
}

const (
        getterFormat = `// %[2]s return %[3]s value
func (t %[1]s) %[2]s() %[4]s {
        return t.%[3]s
}
`
        setterFormat = `// Set%[2]s set v to %[3]s
func (t *%[1]s) Set%[2]s(v %[4]s) {
        t.%[3]s = v
}
`
)

func (g *generator) build(typeName string, typ *ast.StructType, typeParams *ast.FieldList) <span class="cov0" title="0">{
        if typ.Fields.NumFields() == 0 </span><span class="cov0" title="0">{
                log.Fatal("struct has no field")
        }</span>
        <span class="cov0" title="0">exist := false

        typeGenericSig := ""
        if typeParams != nil &amp;&amp; len(typeParams.List) &gt; 0 </span><span class="cov0" title="0">{
                var params []string
                for _, p := range typeParams.List </span><span class="cov0" title="0">{
                        var names []string
                        for _, name := range p.Names </span><span class="cov0" title="0">{
                                names = append(names, name.Name)
                        }</span>
                        <span class="cov0" title="0">constraint := toTypeString(p.Type)
                        params = append(params, fmt.Sprintf("%s %s", strings.Join(names, ", "), constraint))</span>
                }
                <span class="cov0" title="0">typeGenericSig = "[" + strings.Join(params, ", ") + "]"</span>
        }

        <span class="cov0" title="0">for _, field := range typ.Fields.List </span><span class="cov0" title="0">{
                for _, name := range field.Names </span><span class="cov0" title="0">{
                        if name.IsExported() </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">typStr := toTypeString(field.Type)
                        if typStr == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">exportName := upperNameSmart(name.Name)
                        g.Printf(getterFormat, fmt.Sprintf("%s%s", typeName, typeGenericSig), exportName, name.Name, typStr)
                        if g.withSetter </span><span class="cov0" title="0">{
                                g.Printf(setterFormat, fmt.Sprintf("%s%s", typeName, typeGenericSig), exportName, name.Name, typStr)
                        }</span>
                        <span class="cov0" title="0">exist = true</span>
                }
        }

        <span class="cov0" title="0">if !exist </span><span class="cov0" title="0">{
                log.Fatal("struct doesn't have private fields to generate accessors")
        }</span>
}

func toTypeString(exp ast.Expr) string <span class="cov0" title="0">{
        switch x := exp.(type) </span>{
        case *ast.Ident:<span class="cov0" title="0">
                if x.Obj != nil </span><span class="cov0" title="0">{
                        typs := x.Obj.Decl.(*ast.TypeSpec)
                        if !typs.Name.IsExported() </span><span class="cov0" title="0">{
                                return ""
                        }</span>
                }
        case *ast.StarExpr:<span class="cov0" title="0">
                if toTypeString(x.X) == "" </span><span class="cov0" title="0">{
                        return ""
                }</span>
        case *ast.ArrayType:<span class="cov0" title="0">
                if toTypeString(x.Elt) == "" </span><span class="cov0" title="0">{
                        return ""
                }</span>
        case *ast.MapType:<span class="cov0" title="0">
                if toTypeString(x.Key) == "" || toTypeString(x.Value) == "" </span><span class="cov0" title="0">{
                        return ""
                }</span>
        case *ast.FuncType:<span class="cov0" title="0">
                for _, f := range x.Params.List </span><span class="cov0" title="0">{
                        if toTypeString(f.Type) == "" </span><span class="cov0" title="0">{
                                return ""
                        }</span>
                }
                <span class="cov0" title="0">for _, f := range x.Results.List </span><span class="cov0" title="0">{
                        if toTypeString(f.Type) == "" </span><span class="cov0" title="0">{
                                return ""
                        }</span>
                }
        case *ast.StructType:<span class="cov0" title="0">
                return ""</span>
        case *ast.SelectorExpr:<span class="cov0" title="0"></span>
        case *ast.IndexExpr:<span class="cov0" title="0">
                if toTypeString(x.X) == "" || toTypeString(x.Index) == "" </span><span class="cov0" title="0">{
                        return ""
                }</span>
        case *ast.IndexListExpr:<span class="cov0" title="0">
                if toTypeString(x.X) == "" </span><span class="cov0" title="0">{
                        return ""
                }</span>
                <span class="cov0" title="0">for _, idx := range x.Indices </span><span class="cov0" title="0">{
                        if toTypeString(idx) == "" </span><span class="cov0" title="0">{
                                return ""
                        }</span>
                }
        default:<span class="cov0" title="0">
                return ""</span>
        }

        <span class="cov0" title="0">var buf bytes.Buffer
        if err := format.Node(&amp;buf, token.NewFileSet(), exp); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("format ast.Expr failed:%s", err)
        }</span>
        <span class="cov0" title="0">return buf.String()</span>
}

// -----------------------
// smart upperName section
// -----------------------

var initialismsList = []string{
        "ACL", "API", "ASCII", "CPU", "CSS", "DNS", "EOF", "GUID", "HTML", "HTTP", "HTTPS", "ID", "IP", "JSON",
        "QPS", "RAM", "RPC", "SLA", "SMTP", "SQL", "SSH", "TCP", "TLS", "TTL", "UDP", "UI", "GID", "UID", "ULID",
        "UUID", "URI", "URL", "UTF8", "VM", "XML", "XMPP", "XSRF", "XSS", "SIP", "RTP", "AMQP", "DB", "TS",
}
var initialismsMap = makeInitialismsMap(initialismsList)

func makeInitialismsMap(list []string) map[string]string <span class="cov0" title="0">{
        m := make(map[string]string, len(list))
        for _, s := range list </span><span class="cov0" title="0">{
                m[strings.ToLower(s)] = s
        }</span>
        <span class="cov0" title="0">return m</span>
}

var camelCaseMatchParts = regexp.MustCompile(`[A-Z]+[a-z0-9]*|[a-z0-9]+`)

func upperNameSmart(s string) string <span class="cov0" title="0">{
        parts := camelCaseMatchParts.FindAllString(s, -1)
        for i, p := range parts </span><span class="cov0" title="0">{
                lower := strings.ToLower(p)
                if v, ok := initialismsMap[lower]; ok </span><span class="cov0" title="0">{
                        parts[i] = v
                }</span> else<span class="cov0" title="0"> {
                        parts[i] = cases.Title(language.English).String(p)
                }</span>
        }
        <span class="cov0" title="0">return strings.Join(parts, "")</span>
}

// snake case converter
var matchFirstCap = regexp.MustCompile("(.)([A-Z][a-z]+)")
var matchAllCap = regexp.MustCompile("([a-z0-9])([A-Z])")

func camelToSnake(s string) string <span class="cov0" title="0">{
        snake := matchFirstCap.ReplaceAllString(s, "${1}_${2}")
        snake = matchAllCap.ReplaceAllString(snake, "${1}_${2}")
        return strings.ToLower(snake)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
