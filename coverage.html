
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>customer: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ming-0x0/hexago/internal/modules/customer/adapter/repository/customer/adapter.go (0.0%)</option>
				
				<option value="file1">github.com/ming-0x0/hexago/internal/modules/customer/domain/service_type/service_type.go (100.0%)</option>
				
				<option value="file2">github.com/ming-0x0/hexago/internal/modules/customer/port/repository/customer/repository.go (0.0%)</option>
				
				<option value="file3">github.com/ming-0x0/hexago/internal/modules/customer/port/repository/entity/customer.go (0.0%)</option>
				
				<option value="file4">github.com/ming-0x0/hexago/internal/modules/customer/port/repository/repository_provider.go (0.0%)</option>
				
				<option value="file5">github.com/ming-0x0/hexago/internal/shared/dbmocker/dbmocker.go (0.0%)</option>
				
				<option value="file6">github.com/ming-0x0/hexago/internal/shared/domain/email/email.go (100.0%)</option>
				
				<option value="file7">github.com/ming-0x0/hexago/internal/shared/errors/error_code.go (0.0%)</option>
				
				<option value="file8">github.com/ming-0x0/hexago/internal/shared/errors/errors.go (0.0%)</option>
				
				<option value="file9">github.com/ming-0x0/hexago/internal/shared/repository/mock/repository.go (0.0%)</option>
				
				<option value="file10">github.com/ming-0x0/hexago/internal/shared/repository/repository.go (100.0%)</option>
				
				<option value="file11">github.com/ming-0x0/hexago/internal/shared/transaction/mock/transaction.go (0.0%)</option>
				
				<option value="file12">github.com/ming-0x0/hexago/internal/shared/transaction/transaction.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package customer

import (
        "github.com/ming-0x0/hexago/internal/modules/customer/domain/customer"
        "github.com/ming-0x0/hexago/internal/modules/customer/port/repository/entity"
)

type CustomerAdapter struct{}

func (a *CustomerAdapter) ToDomain(ec *entity.Customer) (*customer.Customer, error) <span class="cov0" title="0">{
        return &amp;customer.Customer{}, nil
}</span>

func (a *CustomerAdapter) ToEntity(ec *customer.Customer) (*entity.Customer, error) <span class="cov0" title="0">{
        return &amp;entity.Customer{}, nil
}</span>

func (a *CustomerAdapter) ToDomains(ecs []*entity.Customer) ([]*customer.Customer, error) <span class="cov0" title="0">{
        return []*customer.Customer{}, nil
}</span>

func (a *CustomerAdapter) ToEntities(ds []*customer.Customer) ([]*entity.Customer, error) <span class="cov0" title="0">{
        return []*entity.Customer{}, nil
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package service_type

import (
        validation "github.com/go-ozzo/ozzo-validation/v4"
        "github.com/ming-0x0/hexago/internal/shared/errors"
)

var (
        TuyenDung = ServiceType{value: 1}
        LienHe    = ServiceType{value: 2}
        KhoaHoc   = ServiceType{value: 3}
)

type ServiceType struct {
        value int
}

func (s *ServiceType) Value() int <span class="cov8" title="1">{
        return s.value
}</span>

func New(value int) (*ServiceType, error) <span class="cov8" title="1">{
        s := &amp;ServiceType{value: value}
        if err := s.validate(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return s, nil</span>
}

func (s *ServiceType) validate() error <span class="cov8" title="1">{
        err := validation.ValidateStruct(s,
                validation.Field(
                        &amp;s.value,
                        validation.Required,
                        validation.In(TuyenDung.value, LienHe.value, KhoaHoc.value),
                ),
        )
        if err != nil </span><span class="cov8" title="1">{
                return errors.NewDomainError(errors.Validation, err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package customer

import (
        "github.com/ming-0x0/hexago/internal/modules/customer/domain/customer"
        "github.com/ming-0x0/hexago/internal/modules/customer/port/repository/entity"
        "github.com/ming-0x0/hexago/internal/shared/repository"
        "github.com/sirupsen/logrus"
        "gorm.io/gorm"
)

type CustomerRepositoryInterface interface {
        repository.RepositoryInterface[CustomerAdapterInterface, customer.Customer, entity.Customer]
}

type CustomerRepository struct {
        *repository.Repository[CustomerAdapterInterface, customer.Customer, entity.Customer]
}

func New(db *gorm.DB, logger *logrus.Logger, adapter CustomerAdapterInterface) CustomerRepositoryInterface <span class="cov0" title="0">{
        return &amp;CustomerRepository{
                repository.NewRepository(db, logger, adapter),
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package entity

// CustomersTableName TableName
var CustomersTableName = "customers"

type CustomerStatus int

const (
        ActiveCustomerStatus   CustomerStatus = 1 // đã trả lời
        InactiveCustomerStatus CustomerStatus = 2 // chưa trả lời
)

type ServiceType int

const (
        TuyenDung ServiceType = 1
        LienHe    ServiceType = 2
        KhoaHoc   ServiceType = 3
)

// Customer struct
type Customer struct {
        ID           int     `gorm:"column:id;primaryKey;type:bigint;not null;autoIncrement" mapstructure:"id"`
        CustomerName string  `gorm:"column:customer_name;type:text;not null" mapstructure:"customer_name"`
        Email        string  `gorm:"column:email;type:text;not null" mapstructure:"email"`
        PhoneNumber  string  `gorm:"column:phone_number;type:text;not null" mapstructure:"phone_number"`
        CompanyName  *string `gorm:"column:company_name;type:text" mapstructure:"company_name"`
        Message      *string `gorm:"column:message;type:text" mapstructure:"message"`
        Note         *string `gorm:"column:note;type:text" mapstructure:"note"`
        ServiceType  int     `gorm:"column:service_type;type:int;not null" mapstructure:"service_type"`
        Status       int     `gorm:"column:status;type:int;not null;default:2" mapstructure:"status"`
}

// TableName TableName
func (i *Customer) TableName() string <span class="cov0" title="0">{
        return CustomersTableName
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package repository

import (
        "github.com/ming-0x0/hexago/internal/modules/customer/port/repository/customer"
)

type RepositoryProvider interface {
        CustomerRepository() customer.CustomerRepositoryInterface
}

func NewRepositoryProvider() RepositoryProvider <span class="cov0" title="0">{
        return &amp;repositoryProvider{}
}</span>

type repositoryProvider struct{}

func (rp *repositoryProvider) CustomerRepository() customer.CustomerRepositoryInterface <span class="cov0" title="0">{
        return &amp;customer.CustomerRepository{}
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package dbmocker

import (
        "database/sql"

        "github.com/DATA-DOG/go-sqlmock"
        "github.com/sirupsen/logrus"
        "gorm.io/driver/mysql"
        "gorm.io/gorm"
        gormLog "gorm.io/gorm/logger"
)

type MockedRepository struct {
        DB      *sql.DB
        GormDB  *gorm.DB
        SqlMock sqlmock.Sqlmock
        Logger  *logrus.Logger
}

func NewMockedDB() (*MockedRepository, error) <span class="cov0" title="0">{
        logger := logrus.New()
        logger.SetLevel(logrus.WarnLevel)
        logger.SetFormatter(&amp;logrus.TextFormatter{
                ForceColors: true,
        })
        db, sqlMock, err := sqlmock.New()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">sqlMock.MatchExpectationsInOrder(false)

        gormConfig := &amp;gorm.Config{}
        gormConfig.Logger = gormLog.New(logger, gormLog.Config{
                LogLevel: gormLog.Warn,
                Colorful: true,
        })

        gormDB, err := gorm.Open(
                mysql.New(mysql.Config{
                        Conn:                      db,
                        SkipInitializeWithVersion: true,
                }),
                gormConfig,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;MockedRepository{
                DB:      db,
                GormDB:  gormDB,
                SqlMock: sqlMock,
                Logger:  logger,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package email

import (
        validation "github.com/go-ozzo/ozzo-validation/v4"
        "github.com/go-ozzo/ozzo-validation/v4/is"
        "github.com/ming-0x0/hexago/internal/shared/errors"
)

type Email struct {
        value string
}

func New(value string) (*Email, error) <span class="cov8" title="1">{
        e := &amp;Email{
                value: value,
        }

        if err := e.validate(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return e, nil</span>
}

func (e *Email) Value() string <span class="cov8" title="1">{
        return e.value
}</span>

func (e *Email) validate() error <span class="cov8" title="1">{
        err := validation.ValidateStruct(e,
                validation.Field(&amp;e.value, validation.Required, is.Email),
        )
        if err != nil </span><span class="cov8" title="1">{
                return errors.NewDomainError(errors.Validation, err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package errors

type ErrorCode int

func (e ErrorCode) Code() int <span class="cov0" title="0">{
        return int(e)
}</span>

const (
        // common 1 -&gt; 1000
        System ErrorCode = iota + 1
        Validation
        BadRequest
        NotAuthorized
        Forbidden
        NotFound
        AlreadyExist
        // module specific 1001 -&gt; 2000
)
</pre>
		
		<pre class="file" id="file8" style="display: none">package errors

import "errors"

type DomainError struct {
        ErrCode ErrorCode
        err     error
}

func (e *DomainError) Error() string <span class="cov0" title="0">{
        if e == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return e.err.Error()</span>
}

func (e *DomainError) Unwrap() error <span class="cov0" title="0">{
        if e == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return e.err</span>
}

func (e *DomainError) ErrorCode() ErrorCode <span class="cov0" title="0">{
        if e == nil </span><span class="cov0" title="0">{
                return System
        }</span>
        <span class="cov0" title="0">return e.ErrCode</span>
}

func NewDomainError(errCode ErrorCode, message string) *DomainError <span class="cov0" title="0">{
        return &amp;DomainError{
                ErrCode: errCode,
                err:     errors.New(message),
        }
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ming-0x0/hexago/internal/shared/repository (interfaces: RepositoryInterface)
//
// Generated by this command:
//
//        mockgen -destination mock/repository.go -package mock github.com/ming-0x0/hexago/internal/shared/repository RepositoryInterface
//

// Package mock is a generated GoMock package.
package mock

import (
        context "context"
        reflect "reflect"

        repository "github.com/ming-0x0/hexago/internal/shared/repository"
        gomock "go.uber.org/mock/gomock"
        gorm "gorm.io/gorm"
)

// MockRepositoryInterface is a mock of RepositoryInterface interface.
type MockRepositoryInterface[A repository.AdapterInterface[D, E], D any, E any] struct {
        ctrl     *gomock.Controller
        recorder *MockRepositoryInterfaceMockRecorder[A, D, E]
        isgomock struct{}
}

// MockRepositoryInterfaceMockRecorder is the mock recorder for MockRepositoryInterface.
type MockRepositoryInterfaceMockRecorder[A repository.AdapterInterface[D, E], D any, E any] struct {
        mock *MockRepositoryInterface[A, D, E]
}

// NewMockRepositoryInterface creates a new mock instance.
func NewMockRepositoryInterface[A repository.AdapterInterface[D, E], D any, E any](ctrl *gomock.Controller) *MockRepositoryInterface[A, D, E] <span class="cov0" title="0">{
        mock := &amp;MockRepositoryInterface[A, D, E]{ctrl: ctrl}
        mock.recorder = &amp;MockRepositoryInterfaceMockRecorder[A, D, E]{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepositoryInterface[A, D, E]) EXPECT() *MockRepositoryInterfaceMockRecorder[A, D, E] <span class="cov0" title="0">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockRepositoryInterface[A, D, E]) Create(ctx context.Context, domain *D) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", ctx, domain)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockRepositoryInterfaceMockRecorder[A, D, E]) Create(ctx, domain any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockRepositoryInterface[A, D, E])(nil).Create), ctx, domain)
}</span>

// DeleteByConditions mocks base method.
func (m *MockRepositoryInterface[A, D, E]) DeleteByConditions(ctx context.Context, conditions map[string]any) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteByConditions", ctx, conditions)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteByConditions indicates an expected call of DeleteByConditions.
func (mr *MockRepositoryInterfaceMockRecorder[A, D, E]) DeleteByConditions(ctx, conditions any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteByConditions", reflect.TypeOf((*MockRepositoryInterface[A, D, E])(nil).DeleteByConditions), ctx, conditions)
}</span>

// FindByConditions mocks base method.
func (m *MockRepositoryInterface[A, D, E]) FindByConditions(ctx context.Context, conditions map[string]any, scopes ...func(*gorm.DB) *gorm.DB) ([]*D, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx, conditions}
        for _, a := range scopes </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "FindByConditions", varargs...)
        ret0, _ := ret[0].([]*D)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// FindByConditions indicates an expected call of FindByConditions.
func (mr *MockRepositoryInterfaceMockRecorder[A, D, E]) FindByConditions(ctx, conditions any, scopes ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx, conditions}, scopes...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByConditions", reflect.TypeOf((*MockRepositoryInterface[A, D, E])(nil).FindByConditions), varargs...)
}</span>

// FindByConditionsWithPagination mocks base method.
func (m *MockRepositoryInterface[A, D, E]) FindByConditionsWithPagination(ctx context.Context, pageData map[string]int, conditions map[string]any, scopes ...func(*gorm.DB) *gorm.DB) ([]*D, int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx, pageData, conditions}
        for _, a := range scopes </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "FindByConditionsWithPagination", varargs...)
        ret0, _ := ret[0].([]*D)
        ret1, _ := ret[1].(int64)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2</span>
}

// FindByConditionsWithPagination indicates an expected call of FindByConditionsWithPagination.
func (mr *MockRepositoryInterfaceMockRecorder[A, D, E]) FindByConditionsWithPagination(ctx, pageData, conditions any, scopes ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx, pageData, conditions}, scopes...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByConditionsWithPagination", reflect.TypeOf((*MockRepositoryInterface[A, D, E])(nil).FindByConditionsWithPagination), varargs...)
}</span>

// Save mocks base method.
func (m *MockRepositoryInterface[A, D, E]) Save(ctx context.Context, domain *D) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Save", ctx, domain)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Save indicates an expected call of Save.
func (mr *MockRepositoryInterfaceMockRecorder[A, D, E]) Save(ctx, domain any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Save", reflect.TypeOf((*MockRepositoryInterface[A, D, E])(nil).Save), ctx, domain)
}</span>

// TakeByConditions mocks base method.
func (m *MockRepositoryInterface[A, D, E]) TakeByConditions(ctx context.Context, conditions map[string]any, scopes ...func(*gorm.DB) *gorm.DB) (*D, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx, conditions}
        for _, a := range scopes </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "TakeByConditions", varargs...)
        ret0, _ := ret[0].(*D)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// TakeByConditions indicates an expected call of TakeByConditions.
func (mr *MockRepositoryInterfaceMockRecorder[A, D, E]) TakeByConditions(ctx, conditions any, scopes ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx, conditions}, scopes...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TakeByConditions", reflect.TypeOf((*MockRepositoryInterface[A, D, E])(nil).TakeByConditions), varargs...)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package repository

import (
        "context"
        "errors"

        sharedErrors "github.com/ming-0x0/hexago/internal/shared/errors"
        "github.com/ming-0x0/hexago/internal/shared/transaction"
        "github.com/sirupsen/logrus"
        "gorm.io/gorm"
)

const (
        DefaultPage    = 1
        DefaultPerPage = 20
)

type AdapterInterface[D, E any] interface {
        // ToDomain converts the entity to its domain representation.
        ToDomain(*E) (*D, error)
        // ToEntity converts the domain to its entity representation.
        ToEntity(*D) (*E, error)
        // ToDomains converts the entities to their domain representations.
        ToDomains([]*E) ([]*D, error)
        // ToEntities converts the domains to their entity representations.
        ToEntities([]*D) ([]*E, error)
}

//go:generate go tool mockgen -destination mock/repository.go -package mock github.com/ming-0x0/hexago/internal/shared/repository RepositoryInterface
type RepositoryInterface[A AdapterInterface[D, E], D, E any] interface {
        Create(
                ctx context.Context,
                domain *D,
        ) error
        FindByConditions(
                ctx context.Context,
                conditions map[string]any,
                scopes ...func(*gorm.DB) *gorm.DB,
        ) ([]*D, error)
        TakeByConditions(
                ctx context.Context,
                conditions map[string]any,
                scopes ...func(*gorm.DB) *gorm.DB,
        ) (*D, error)
        Save(
                ctx context.Context,
                domain *D,
        ) error
        DeleteByConditions(
                ctx context.Context,
                conditions map[string]any,
        ) error
        FindByConditionsWithPagination(
                ctx context.Context,
                pageData map[string]int,
                conditions map[string]any,
                scopes ...func(*gorm.DB) *gorm.DB,
        ) ([]*D, int64, error)
}

type Repository[A AdapterInterface[D, E], D, E any] struct {
        db      *gorm.DB
        logger  *logrus.Logger
        adapter A
}

func NewRepository[A AdapterInterface[D, E], D, E any](
        db *gorm.DB,
        logger *logrus.Logger,
        adapter A,
) *Repository[A, D, E] <span class="cov8" title="1">{
        return &amp;Repository[A, D, E]{
                db:      db,
                logger:  logger,
                adapter: adapter,
        }
}</span>

func (r *Repository[A, D, E]) DB(ctx context.Context) *gorm.DB <span class="cov8" title="1">{
        if tx, ok := transaction.TransactionFromContext(ctx); ok </span><span class="cov8" title="1">{
                return tx
        }</span>

        <span class="cov8" title="1">return r.db.WithContext(ctx)</span>
}

func (r *Repository[A, D, E]) pagination(pageData map[string]int) func(*gorm.DB) *gorm.DB <span class="cov8" title="1">{
        return func(db *gorm.DB) *gorm.DB </span><span class="cov8" title="1">{
                page := DefaultPage
                if valPage, ok := pageData["page"]; ok &amp;&amp; valPage &gt; 0 </span><span class="cov8" title="1">{
                        page = valPage
                }</span>

                <span class="cov8" title="1">pageSize := DefaultPerPage
                if valPageSize, ok := pageData["limit"]; ok &amp;&amp; valPageSize &gt; 0 </span><span class="cov8" title="1">{
                        pageSize = valPageSize
                }</span>

                <span class="cov8" title="1">offset := (page - 1) * pageSize
                return db.Offset(offset).Limit(pageSize)</span>
        }
}

func (r *Repository[A, D, E]) Create(
        ctx context.Context,
        domain *D,
) error <span class="cov8" title="1">{
        entity, err := r.adapter.ToEntity(domain)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = r.DB(ctx).Create(entity).Error
        if err != nil </span><span class="cov8" title="1">{
                return sharedErrors.NewDomainError(sharedErrors.System, err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *Repository[A, D, E]) FindByConditions(
        ctx context.Context,
        conditions map[string]any,
        scopes ...func(*gorm.DB) *gorm.DB,
) ([]*D, error) <span class="cov8" title="1">{
        var entities []*E
        if err := r.DB(ctx).Scopes(scopes...).Where(conditions).Find(&amp;entities).Error; err != nil </span><span class="cov8" title="1">{
                return nil, sharedErrors.NewDomainError(sharedErrors.System, err.Error())
        }</span>

        <span class="cov8" title="1">return r.adapter.ToDomains(entities)</span>
}

func (r *Repository[A, D, E]) TakeByConditions(
        ctx context.Context,
        conditions map[string]any,
        scopes ...func(*gorm.DB) *gorm.DB,
) (*D, error) <span class="cov8" title="1">{
        entity := new(E)
        err := r.DB(ctx).Scopes(scopes...).Where(conditions).Take(entity).Error
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                        return nil, sharedErrors.NewDomainError(sharedErrors.NotFound, err.Error())
                }</span>

                <span class="cov8" title="1">return nil, sharedErrors.NewDomainError(sharedErrors.System, err.Error())</span>
        }

        <span class="cov8" title="1">return r.adapter.ToDomain(entity)</span>
}

func (r *Repository[A, D, E]) Save(
        ctx context.Context,
        domain *D,
) error <span class="cov8" title="1">{
        entity, err := r.adapter.ToEntity(domain)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = r.DB(ctx).Save(entity).Error
        if err != nil </span><span class="cov8" title="1">{
                return sharedErrors.NewDomainError(sharedErrors.System, err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *Repository[A, D, E]) DeleteByConditions(
        ctx context.Context,
        conditions map[string]any,
) error <span class="cov8" title="1">{
        entity := new(E)
        err := r.DB(ctx).Where(conditions).Delete(entity).Error
        if err != nil </span><span class="cov8" title="1">{
                return sharedErrors.NewDomainError(sharedErrors.System, err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *Repository[A, D, E]) FindByConditionsWithPagination(
        ctx context.Context,
        pageData map[string]int,
        conditions map[string]any,
        scopes ...func(*gorm.DB) *gorm.DB,
) ([]*D, int64, error) <span class="cov8" title="1">{
        cdb := r.DB(ctx)

        var entities []*E
        var count int64

        countBuilder := cdb.Model(&amp;entities)
        queryBuilder := cdb.Scopes(r.pagination(pageData))

        err := countBuilder.Scopes(scopes...).Where(conditions).Count(&amp;count).Error
        if err != nil </span><span class="cov8" title="1">{
                return []*D{}, 0, sharedErrors.NewDomainError(sharedErrors.System, err.Error())
        }</span>

        <span class="cov8" title="1">err = queryBuilder.Scopes(scopes...).Where(conditions).Find(&amp;entities).Error
        if err != nil </span><span class="cov8" title="1">{
                return []*D{}, 0, sharedErrors.NewDomainError(sharedErrors.System, err.Error())
        }</span>

        <span class="cov8" title="1">domains, err := r.adapter.ToDomains(entities)
        if err != nil </span><span class="cov8" title="1">{
                return []*D{}, 0, err
        }</span>

        <span class="cov8" title="1">return domains, count, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ming-0x0/hexago/internal/shared/transaction (interfaces: TransactionInterface)
//
// Generated by this command:
//
//        mockgen -destination mock/transaction.go -package mock github.com/ming-0x0/hexago/internal/shared/transaction TransactionInterface
//

// Package mock is a generated GoMock package.
package mock

import (
        context "context"
        reflect "reflect"

        gomock "go.uber.org/mock/gomock"
)

// MockTransactionInterface is a mock of TransactionInterface interface.
type MockTransactionInterface struct {
        ctrl     *gomock.Controller
        recorder *MockTransactionInterfaceMockRecorder
        isgomock struct{}
}

// MockTransactionInterfaceMockRecorder is the mock recorder for MockTransactionInterface.
type MockTransactionInterfaceMockRecorder struct {
        mock *MockTransactionInterface
}

// NewMockTransactionInterface creates a new mock instance.
func NewMockTransactionInterface(ctrl *gomock.Controller) *MockTransactionInterface <span class="cov0" title="0">{
        mock := &amp;MockTransactionInterface{ctrl: ctrl}
        mock.recorder = &amp;MockTransactionInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTransactionInterface) EXPECT() *MockTransactionInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Do mocks base method.
func (m *MockTransactionInterface) Do(ctx context.Context, fn func(context.Context) error) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Do", ctx, fn)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Do indicates an expected call of Do.
func (mr *MockTransactionInterfaceMockRecorder) Do(ctx, fn any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Do", reflect.TypeOf((*MockTransactionInterface)(nil).Do), ctx, fn)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package transaction

import (
        "context"

        "gorm.io/gorm"
)

type TxKey string

const (
        Tx TxKey = "tx"
)

//go:generate go tool mockgen -destination mock/transaction.go -package mock github.com/ming-0x0/hexago/internal/shared/transaction TransactionInterface
type TransactionInterface interface {
        Do(ctx context.Context, fn func(ctx context.Context) error) error
}

type Transaction struct {
        db *gorm.DB
}

func NewTransaction(db *gorm.DB) *Transaction <span class="cov8" title="1">{
        return &amp;Transaction{
                db: db,
        }
}</span>

func (t *Transaction) Do(ctx context.Context, fn func(ctx context.Context) error) error <span class="cov8" title="1">{
        return t.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov8" title="1">{
                ctx = context.WithValue(ctx, Tx, tx)
                return fn(ctx)
        }</span>)
}

func TransactionFromContext(ctx context.Context) (*gorm.DB, bool) <span class="cov8" title="1">{
        v := ctx.Value(Tx)
        if v != nil </span><span class="cov8" title="1">{
                if tx, ok := v.(*gorm.DB); ok </span><span class="cov8" title="1">{
                        return tx, true
                }</span>
        }
        <span class="cov8" title="1">return nil, false</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
